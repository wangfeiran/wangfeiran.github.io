{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Feiran Wang","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"【C++模板】函数模板","slug":"【C-模板】函数模板","date":"2021-03-11T15:02:19.000Z","updated":"2021-04-06T15:48:44.924Z","comments":true,"path":"2021/03/11/【C-模板】函数模板/","link":"","permalink":"http://yoursite.com/2021/03/11/%E3%80%90C-%E6%A8%A1%E6%9D%BF%E3%80%91%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"函数模板是那些被参数化的函数，他们代表的是一个函数家族。 1. 初探函数模板函数模板提供了一种函数行为，这种函数行为可以被 不同的类型 进行调用。 如： 12345template &lt;typename T&gt;T const&amp; max(T const&amp; a, T const&amp; b)&#123; return a &lt; b ? b : a;&#125; 如上模板定义了返回两个值中的最大值得函数模板，参数类型没确定，用模板T代替。但并不是任意类型都可以调用这个函数模板，类型必须要支持&lt;操作。 模板参数的声明语法 1template &lt;comma-separated-list-parameters&gt; 模板编译时，并不是将其编译成一个可以处理任何类型的单一实体；而是对于实例化模板参数的每种类型，都从模板产生出一个不同的实体。针对每种类型，模板都会编译一次。这种用具体类型代替模板参数的过程叫做 实例化（initantitiation）。 模板被编译了两次：1）实例化之前，先检查模板代码本身，查看语法是否正确；在这里会发现模板的语法错误，如遗漏分号等2）在实例化期间，检查模板代码，查看是否所有的调用都是有效的；在这里会发现无效的调用，如实例化类型不支持某些函数调用等 2. 实参的演绎（deduction）不允许进行自动类型转换，每个T都必须正确地匹配 1234567891011template &lt;typename T&gt;T const&amp; max(T const&amp; a, T const&amp; b);...max(4,7); &#x2F;&#x2F; OK;两个实参类型都为intmax(4, 4.2); &#x2F;&#x2F; ERROR;第一个T为int，第二个T为double可用如下方法正确调用：max(static_cast&lt;double&gt;(4), 4.2);max&lt;double&gt;(4, 4.2);template &lt;typename T1, typename T2&gt;T1 max(T1 const&amp; a, T2 const&amp; b); 3. 模板参数函数模板有两类参数：1）模板参数： 1template &lt;typename T&gt; &#x2F;&#x2F; T为模板参数 2）调用参数： 1T const&amp; max(T const&amp; a, T const&amp; b); &#x2F;&#x2F; a和b为调用参数 函数模板不能指定缺省的模板实参。 函数模板的实参演绎，但模板实参演绎并不适合返回值。实参演绎和函数入参的默认值类似，必须指定“最后一个不能被隐式演绎的模板实参之前的”所有实参类型。 4. 重载函数模板和普通函数一样，模板函数也可以被重载。 12345678910111213141516171819202122232425inline int const&amp; max(int const&amp; a, int cosnt&amp; b)&#123; return a &lt; b ? b : a;&#125;template &lt;typename T&gt;inline T cosnt&amp; max(T const&amp; a, T const&amp; b)&#123; return a &lt; b ? b : a;&#125;template &lt;typename T&gt;inline T cosnt&amp; max(T const&amp; a, T const&amp; b, T const&amp; c)&#123; return ::max(::max(a, b), c);&#125;call:::max(7, 42, 68); &#x2F;&#x2F; 调用三个参数的模板::max(7.0, 42.0); &#x2F;&#x2F; 调用二参模板，实参演绎为double::max(&#39;a&#39;, &#39;b&#39;); &#x2F;&#x2F; 调用二参模板，实参演绎为char::max(7, 42); &#x2F;&#x2F; 调用int非模板函数::max&lt;&gt;(7, 42); &#x2F;&#x2F; 调用二参模板，实参演绎为int::max&lt;double&gt;(7, 42); &#x2F;&#x2F; 调用max&lt;double&gt;，没有实参演绎::max(&#39;a&#39;, 42.7); &#x2F;&#x2F; 调用int非模板函数 模板不允许自动类型转换；但普通函数可以进行自动类型转换。","categories":[],"tags":[]},{"title":"网络库学习/libhv学习","slug":"网络库学习/libhv学习","date":"2020-11-30T14:08:29.874Z","updated":"2020-12-20T14:59:02.457Z","comments":true,"path":"2020/11/30/网络库学习/libhv学习/","link":"","permalink":"http://yoursite.com/2020/11/30/%E7%BD%91%E7%BB%9C%E5%BA%93%E5%AD%A6%E4%B9%A0/libhv%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"httpdhttpd是Apache超文本传输协议（HTTP）服务器的主程序。被设计为一个独立运行的后台程序，它会建立一个处理请求的子进程或线程的池。","categories":[],"tags":[]},{"title":"【设计模式】学习","slug":"【设计模式】学习","date":"2020-08-09T16:19:36.376Z","updated":"2020-08-09T16:19:36.376Z","comments":true,"path":"2020/08/10/【设计模式】学习/","link":"","permalink":"http://yoursite.com/2020/08/10/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"【设计模式】 之 创建型模式创建型设计模式抽象了实例化过程。 类创建型模式：使用继承改变被实例化的类； 对象创建型模式：将实例化委托给另一个对象。","categories":[],"tags":[]},{"title":"【设计模式】创建型模式","slug":"【设计模式】创建型模式","date":"2020-08-09T14:58:28.746Z","updated":"2020-08-09T14:58:28.786Z","comments":true,"path":"2020/08/09/【设计模式】创建型模式/","link":"","permalink":"http://yoursite.com/2020/08/09/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"ggg","categories":[],"tags":[]},{"title":"How to avoid bugs using modern C++","slug":"how to avoid bugs in modern Cplusplus","date":"2020-07-09T15:55:21.000Z","updated":"2020-07-09T15:43:55.588Z","comments":true,"path":"2020/07/09/how to avoid bugs in modern Cplusplus/","link":"","permalink":"http://yoursite.com/2020/07/09/how%20to%20avoid%20bugs%20in%20modern%20Cplusplus/","excerpt":"","text":"原文地址： http://www.cplusplus.com/articles/y807M4Gy/ How to avoid bugs using modern C++ C ++的主要问题之一是具有大量结构，这些结构的行为是不确定的，或者对于程序员而言是的。 在各种项目中使用静态分析器时，我们经常会遇到它们。 但是，众所周知，最好的办法是在编译阶段检测错误。 让我们看看现代C ++中的哪些技术不仅可以帮助编写简单明了的代码，而且可以使代码更安全，更可靠。 What is Modern C++?在C ++ 11发布之后，现代C ++一词变得非常流行。这是什么意思？首先，现代C ++是一组模式和习惯用法，旨在消除旧的“带有类的C”的弊端，以至于许多C ++程序员已经习惯了，尤其是如果他们开始使用C编程。C ++ 11看起来更简洁易懂，这非常重要。 人们在谈论现代C ++时通常会想到什么？并行性，编译时计算，RAII，lambda，范围，概念，模块以及标准库的其他同等重要的组件（例如，用于文件系统的API）。这些都是非常酷的现代化，我们期待在下一组标准中看到它们。但是，我想提请注意新标准允许编写更安全的代码的方式。在开发静态分析器时，我们会看到大量不同的错误，有时我们不禁会想到：“但是在现代C ++中，这是可以避免的”。因此，我建议我们检查PVS-Studio在各种开源项目中发现的几个错误。另外，我们将看到如何修复它们。 Automatic type inference","categories":[],"tags":[]},{"title":"C++ Lambda表达式详解","slug":"【C++】Lambda表达式详解","date":"2020-07-09T15:55:21.000Z","updated":"2020-07-09T15:52:38.948Z","comments":true,"path":"2020/07/09/【C++】Lambda表达式详解/","link":"","permalink":"http://yoursite.com/2020/07/09/%E3%80%90C++%E3%80%91Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"C++ Lambda表达式详解C++ 11新引入了lambda表达式语法，使得使用函数就像使用对象一样，十分方便。但是在方便的同时，lambda表达式也有许多坑，在使用时不注意可能会出问题。语法12341) [captures] &lt;tparams&gt;(optional)(C++20) (params) specifiers exception attr -&gt; ret requires(optional)(C++20) &#123;body&#125;2) [captures] (params) -&gt; ret &#123;body&#125;3) [captures] (params) &#123;body&#125;4) [captures] &#123;body&#125; 语法解释1 captures捕获列表，捕获声明lambda表达式处作用域内的对象。 捕获可以为空，也可以是一个捕获符，或用逗号分隔的多个捕获符。默认捕获符有两个 &amp;（以引用捕获） 和 =（以复制捕获）。当出现任意一类默认捕获符时，都能隐式捕获当前对象（*this） 当默认捕获符是&amp;时，后继的简单捕获符必须不以&amp;开始。123456789struct S2 &#123;void f(int i);&#125;;void S2::f(int i)&#123; [&amp;]&#123;&#125;; &#x2F;&#x2F; OK: 默认以引用捕获 [&amp;, i]&#123;&#125;; &#x2F;&#x2F; OK: 以引用捕获，但i以值捕获 [&amp;, &amp;i]&#123;&#125;; &#x2F;&#x2F; 错误: [&amp;, this]; &#x2F;&#x2F; OK: 等价于[&amp;] [&amp;, this, i]&#123;&#125;; &#x2F;&#x2F; OK: 等价于[&amp;, i]&#125; 当默认捕获符是=时，后继的简单捕获符必须以&amp;开始，或者为*this(C++17)/this(C++20)12345678910struct S2 &#123; void f(int i); &#125;;void S2::f(int i)&#123; [&#x3D;]&#123;&#125;; &#x2F;&#x2F; OK：默认以复制捕获 [&#x3D;, &amp;i]&#123;&#125;; &#x2F;&#x2F; OK：以复制捕获，但 i 以引用捕获 [&#x3D;, *this]&#123;&#125;; &#x2F;&#x2F; C++17 前：错误：无效语法 &#x2F;&#x2F; C++17 起：OK：以复制捕获外围的 S2 [&#x3D;, this] &#123;&#125;; &#x2F;&#x2F; C++20 前：错误：&#x3D; 为默认时的 this &#x2F;&#x2F; C++20 起：OK：同 [&#x3D;]&#125; 任何捕获符只可以出现一次123456struct S2 &#123; void f(int i); &#125;;void S2::f(int i)&#123; [i, i] &#123;&#125;; &#x2F;&#x2F; 错误：i 重复 [this, *this] &#123;&#125;; &#x2F;&#x2F; 错误：&quot;this&quot; 重复 (C++17)&#125; 【&lt;tparams&gt;】 : (C++20)模板参数 【params】 : 参数列表。C++14开始支持默认参数 【specifiers】 : 可用mutable，constexpr(C++17)和consteval(C++20) 【exception】 : 【attr】 : 【ret】 : 返回值 【requires】 : 【body】 : 一般用法注意事项参考文献","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-04-06T15:50:18.436Z","updated":"2020-04-06T15:50:18.436Z","comments":true,"path":"2020/04/06/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}